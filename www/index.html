
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Fractube</title>
<style>
  html, body { margin:0; height:100%; background:#000; }
  canvas { 
    display:block; width:100vw; height:100vh;
  }
  .point-filtered {
    image-rendering: -webkit-crisp-edges;
    image-rendering: -moz-crisp-edges;
    image-rendering: crisp-edges;
    image-rendering: pixelated;
  }
  .smooth-filtered {
    image-rendering: auto;
  }
  #ui {
    position: fixed; top: 10px; left: 10px;
    background: rgba(0,0,0,0.85); color:#bdf; font:12px/1.2 monospace;
    border-radius:8px; user-select:none; min-width:300px;
    transition: all 0.3s ease;
  }
  #ui-header {
    padding: 10px;
    border-bottom: 1px solid #444;
    display: flex;
    justify-content: space-between;
    align-items: center;
    cursor: pointer;
  }
  #ui-title {
    font-weight: bold;
    color: #ff6;
    font-size: 14px;
  }
  #ui-toggle {
    background: none;
    border: none;
    color: #bdf;
    font-size: 16px;
    cursor: pointer;
    padding: 0;
    width: 20px;
    height: 20px;
    display: flex;
    align-items: center;
    justify-content: center;
  }
  #ui-content {
    padding: 10px;
    max-height: 80vh;
    overflow-y: auto;
    transition: all 0.3s ease;
  }
  #ui.collapsed #ui-content {
    display: none;
  }
  #ui.collapsed {
    min-width: auto;
  }
  
  label { display:block; margin:8px 0 4px; color:#9ff; font-size:11px; }
  .param-group { margin-bottom: 12px; }
  .dual-slider, .quad-slider {
    display: flex;
    gap: 4px;
    align-items: center;
  }
  .dual-slider input[type=range] {
    flex: 1;
  }
  .dual-slider .coarse { min-width: 180px; }
  .dual-slider .fine { min-width: 80px; }
  
  .quad-slider input[type=range] {
    flex: 1;
  }
  .quad-slider .coarse { min-width: 140px; }
  .quad-slider .fine { min-width: 50px; }
  
  .val { color:#ff0; margin-left:6px; font-weight: bold; }
  .row { display:flex; align-items:center; gap:8px; margin:4px 0; }
  button {
    background: #444; color: #bdf; border: 1px solid #666;
    padding: 4px 8px; border-radius: 3px; font: inherit;
    cursor: pointer; min-width: 24px;
    font-size: 11px;
  }
  button:hover { background: #555; }
  button:active { background: #333; }
  
  .action-btn {
    margin-top: 8px;
    padding: 6px 12px;
    width: 100%;
  }
  .download-btn { background: #006600; }
  .download-btn:hover { background: #008800; }
  .share-btn { background: #006666; }
  .share-btn:hover { background: #008888; }
  
  .section-divider {
    border-top: 1px solid #444;
    margin: 12px 0 8px 0;
    padding-top: 8px;
  }
  .info-display {
    font-size: 10px;
    color: #999;
    margin: 4px 0;
    font-family: inherit;
  }
  .zoom-controls {
    display: flex; align-items: center; gap: 8px; margin-top: 4px;
  }
  .zoom-speed-info {
    font-size: 10px;
    color: #666;
    margin-top: 2px;
  }
  
  /* URL input field */
  #url-input {
    background: #222;
    border: 1px solid #555;
    color: #ccc;
    font-size: 10px;
    padding: 6px;
    width: 100%;
    box-sizing: border-box;
    font-family: inherit;
    border-radius: 3px;
    margin: 4px 0;
  }
  #url-input:focus {
    outline: none;
    border-color: #888;
    background: #333;
  }
  #url-input:read-only {
    cursor: pointer;
  }
  
  /* Copyright notice */
  .copyright {
    position: fixed;
    bottom: 10px;
    right: 10px;
    color: rgba(255,255,255,0.3);
    font-size: 10px;
    font-family: monospace;
    background: rgba(0,0,0,0.5);
    padding: 4px 8px;
    border-radius: 3px;
    user-select: none;
  }
</style>
</head>
<body>
<canvas id="glcanvas"></canvas>

<div class="collapsed" id="ui">
  <div id="ui-header" onclick="toggleUI()">
    <span id="ui-title">üåÄ FRACTUBE</span>
    <button id="ui-toggle"></button>
  </div>
  <div id="ui-content">
     <!-- Actions -->
     <div class="section-divider">
      <label>Actions</label>
    </div>
    <button id="resetBtn" class="action-btn">üéØ Reset View</button>
    <button id="shareBtn" class="action-btn share-btn">üîó Copy Share URL</button>
    <button id="downloadBtn" class="action-btn download-btn">üíæ Download PNG</button>
    
    <!-- URL Display -->
    <div class="section-divider">
      <label>Share URL</label>
    </div>
    <input type="text" id="url-input" readonly placeholder="URL will appear here..." onclick="this.select()">
    
    <div style="margin-top:8px; color:#9a9; font-size:10px;">Mouse: drag=pan, wheel=zoom</div>
    <!-- Fractal Parameters -->
    <div class="param-group">
      <label>Iterations <span class="val" id="iterVal">64</span></label>
      <div class="dual-slider">
        <input id="iter" type="range" min="4" max="256" step="1" value="64" class="coarse">
        <input id="iterFine" type="range" min="-32" max="32" step="1" value="0" class="fine">
      </div>
    </div>
    
    <div class="param-group">
      <label>Scale <span class="val" id="scaleVal">0.500</span></label>
      <div class="quad-slider">
        <input id="scale" type="range" min="-2.0" max="2.0" step="0.001" value="0.000" class="coarse">
        <input id="scaleFine1" type="range" min="-0.1" max="0.1" step="0.001" value="0.0" class="fine">
        <input id="scaleFine2" type="range" min="-0.01" max="0.01" step="0.0001" value="0.0" class="fine">
        <input id="scaleFine3" type="range" min="-0.001" max="0.001" step="0.00001" value="0.0" class="fine">
      </div>
    </div>
    
    <div class="param-group">
      <label>Density <span class="val" id="densVal">0.100</span></label>
      <div class="dual-slider">
        <input id="dens" type="range" min="-3.14159265359" max="3.14159265359" step="0.001" value="0.069" class="coarse">
        <input id="densFine" type="range" min="-0.1" max="0.1" step="0.001" value="0.0" class="fine">
      </div>
    </div>
    
    <div class="param-group">
      <label>Speed <span class="val" id="spdVal">1.2222222</span></label>
      <div class="dual-slider">
        <input id="speed" type="range" min="0.0" max="2.0" step="0.001" value="0.0" class="coarse">
        <input id="speedFine" type="range" min="-0.1" max="0.1" step="0.001" value="0.0" class="fine">
      </div>
    </div>
    
    <div class="param-group">
      <label>Color Freq <span class="val" id="cfVal">0.273</span></label>
      <div class="dual-slider">
        <input id="cf" type="range" min="0.0" max="10.0" step="0.001" value="0.395" class="coarse">
        <input id="cfFine" type="range" min="-0.5" max="0.5" step="0.001" value="0.0" class="fine">
      </div>
    </div>
    
    <div class="param-group">
      <label>Color Contract <span class="val" id="contractVal">2.000</span></label>
      <div class="dual-slider">
        <input id="contract" type="range" min="0.0" max="3.0" step="0.001" value="2.0" class="coarse">
        <input id="contractFine" type="range" min="-0.1" max="0.1" step="0.001" value="0.0" class="fine">
      </div>
    </div>
    
    <div class="param-group">
      <label>Saturation <span class="val" id="satVal">1.000</span></label>
      <div class="dual-slider">
        <input id="sat" type="range" min="0.0" max="1.0" step="0.001" value="1.0" class="coarse">
        <input id="satFine" type="range" min="-0.1" max="0.1" step="0.001" value="0.0" class="fine">
      </div>
    </div>
    
    <div class="param-group">
      <label>Brightness <span class="val" id="brightnessVal">2.000</span></label>
      <div class="dual-slider">
        <input id="brightness" type="range" min="0.0" max="2.0" step="0.001" value="1.10" class="coarse">
        <input id="brightnessFine" type="range" min="-0.1" max="0.1" step="0.001" value="0.0" class="fine">
      </div>
    </div>
    
    <div class="param-group">
      <label>Phase <span class="val" id="phVal">0.000</span></label>
      <div class="dual-slider">
        <input id="ph" type="range" min="0.0" max="6.28" step="0.001" value="2.748" class="coarse">
        <input id="phFine" type="range" min="-0.2" max="0.2" step="0.001" value="0.0" class="fine">
      </div>
    </div>
    
    <!-- Rendering Options -->
    <div class="section-divider">
      <label>Rendering</label>
    </div>
    
    <div class="param-group">
      <label>Resolution <span class="val" id="resVal">1.000</span></label>
      <div class="dual-slider">
        <input id="resolution" type="range" min="0.0" max="1.0" step="0.04" value="1.0" class="coarse">
        <input id="resFine" type="range" min="-0.25" max="0.25" step="0.001" value="0.0" class="fine">
      </div>
      <div class="info-display">
        <span id="resolutionInfo">1920√ó1080 (native)</span>
      </div>
    </div>
    
    <div class="row">
      <label><input type="checkbox" id="antialiasing" checked> Anti-aliasing</label>
      <label><input type="checkbox" id="grayscale" checked> Grayscale</label>
    </div>
    
    <!-- Navigation -->
    <div class="section-divider">
      <label>Navigation</label>
    </div>
    <div class="info-display">
      Zoom: <span id="zoomInfo">1.00000000</span>√ó
    </div>
    <div class="info-display">
      Pan: (<span id="panXInfo">0.00000000</span>, <span id="panYInfo">0.00000000</span>)
    </div>
    
    <div class="row">
      <label><input type="checkbox" id="centerZoom"> Center zoom</label>
    </div>
    
    <!-- Animated Zoom -->
    <div class="param-group">
      <label>Auto Zoom <span class="val" id="zoomSpeedVal">0.000</span></label>
      <div class="dual-slider">
        <input id="zoomSpeed" type="range" min="0.0" max="1.0" step="0.001" value="0.0" class="coarse">
        <input id="zoomSpeedFine" type="range" min="-0.1" max="0.1" step="0.001" value="0.0" class="fine">
      </div>
      <div class="zoom-controls">
        <label><input type="checkbox" id="zoomDirection"> Zoom Out</label>
        <button id="stopZoom">‚èπ Stop</button>
      </div>
      <div class="zoom-speed-info">
        <span id="zoomSpeedInfo">Stopped</span>
      </div>
    </div>
    
   
  </div>
</div>

<!-- Copyright Notice -->
<div class="copyright">
  Fractube ¬© 2025
</div>

<script>
const canvas = document.getElementById('glcanvas');
const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
if (!gl) { alert('WebGL not supported'); throw new Error('No WebGL'); }

// UI Collapse functionality
function toggleUI() {
  const ui = document.getElementById('ui');
  const toggle = document.getElementById('ui-toggle');
  ui.classList.toggle('collapsed');
  toggle.textContent = ui.classList.contains('collapsed') ? '‚ñ∂' : '‚ñº';
}

// Parameter defaults (updated with new great defaults)
const defaultParams = {
  iter: 64, scale: 0.5, dens: 0.1, speed: 1.228,
  cf: 0.819, contract: 2.0, sat: 1.0, brightness: 2.0, ph: 0.0, res: 1.0,
  zoom: 1.0, panX: 0.0, panY: 0.0, zoomSpeed: 0.0,
  centerZoom: false, zoomDirection: false,
  antialiasing: false, grayscale: true
};

// Navigation state (updated with new defaults)
let pan = {x: 0, y: 0};
let zoom = 1.0;
let dragging = false;
let last = {x: 0, y: 0};

// URL update timeout
let urlUpdateTimeout;

// Info display elements
const resolutionInfo = document.getElementById('resolutionInfo');
const zoomInfo = document.getElementById('zoomInfo');
const panXInfo = document.getElementById('panXInfo');
const panYInfo = document.getElementById('panYInfo');
const zoomSpeedInfo = document.getElementById('zoomSpeedInfo');
const urlInput = document.getElementById('url-input');

// URL encoding/decoding functions
function updateURL() {
  clearTimeout(urlUpdateTimeout);
  urlUpdateTimeout = setTimeout(() => {
    const url = encodeURL();
    urlInput.value = url;
  }, 100);
}

// Dual slider system
function createDualSlider(coarseId, fineId, labelId, decimals = 3) {
  const coarse = document.getElementById(coarseId);
  const fine = document.getElementById(fineId);
  const label = document.getElementById(labelId);
  
  const update = () => {
    const coarseVal = parseFloat(coarse.value);
    const fineVal = parseFloat(fine.value);
    const total = coarseVal + fineVal;
    
    // Clamp fine adjustment if it would exceed coarse bounds
    const minTotal = parseFloat(coarse.min);
    const maxTotal = parseFloat(coarse.max);
    const clampedTotal = Math.max(minTotal, Math.min(maxTotal, total));
    
    if (clampedTotal !== total) {
      fine.value = (clampedTotal - coarseVal).toFixed(3);
    }
    
    label.textContent = clampedTotal.toFixed(decimals);
    updateURL();
  };
  
  coarse.addEventListener('input', update);
  fine.addEventListener('input', update);
  update();
  
  return {
    getValue: () => parseFloat(coarse.value) + parseFloat(fine.value),
    setValue: (val) => {
      const baseVal = Math.max(parseFloat(coarse.min), Math.min(parseFloat(coarse.max), val));
      const fineVal = val - baseVal;
      coarse.value = baseVal.toFixed(3);
      fine.value = fineVal.toFixed(3);
      update();
    }
  };
}

// Quad slider system for ultra-precise scale control
function createQuadSlider(coarseId, fine1Id, fine2Id, fine3Id, labelId, decimals = 3) {
  const coarse = document.getElementById(coarseId);
  const fine1 = document.getElementById(fine1Id);
  const fine2 = document.getElementById(fine2Id);
  const fine3 = document.getElementById(fine3Id);
  const label = document.getElementById(labelId);
  
  const update = () => {
    const coarseVal = parseFloat(coarse.value);
    const fine1Val = parseFloat(fine1.value);
    const fine2Val = parseFloat(fine2.value);
    const fine3Val = parseFloat(fine3.value);
    const total = coarseVal + fine1Val + fine2Val + fine3Val;
    
    // Clamp total if it would exceed coarse bounds
    const minTotal = parseFloat(coarse.min);
    const maxTotal = parseFloat(coarse.max);
    const clampedTotal = Math.max(minTotal, Math.min(maxTotal, total));
    
    label.textContent = clampedTotal.toFixed(decimals);
    updateURL();
  };
  
  coarse.addEventListener('input', update);
  fine1.addEventListener('input', update);
  fine2.addEventListener('input', update);
  fine3.addEventListener('input', update);
  update();
  
  return {
    getValue: () => parseFloat(coarse.value) + parseFloat(fine1.value) + parseFloat(fine2.value) + parseFloat(fine3.value),
    setValue: (val) => {
      const baseVal = Math.max(parseFloat(coarse.min), Math.min(parseFloat(coarse.max), val));
      const fineVal = val - baseVal;
      coarse.value = baseVal.toFixed(3);
      fine1.value = Math.max(-0.1, Math.min(0.1, fineVal)).toFixed(3);
      fine2.value = 0;
      fine3.value = 0;
      update();
    }
  };
}

// Initialize all sliders
const params = {
  iter: createDualSlider('iter', 'iterFine', 'iterVal', 0),
  scale: createQuadSlider('scale', 'scaleFine1', 'scaleFine2', 'scaleFine3', 'scaleVal', 3),
  dens: createDualSlider('dens', 'densFine', 'densVal', 3),
  speed: createDualSlider('speed', 'speedFine', 'spdVal', 3),
  cf: createDualSlider('cf', 'cfFine', 'cfVal', 3),
  contract: createDualSlider('contract', 'contractFine', 'contractVal', 3),
  sat: createDualSlider('sat', 'satFine', 'satVal', 3),
  brightness: createDualSlider('brightness', 'brightnessFine', 'brightnessVal', 3),
  ph: createDualSlider('ph', 'phFine', 'phVal', 3),
  res: createDualSlider('resolution', 'resFine', 'resVal', 3),
  zoomSpeed: createDualSlider('zoomSpeed', 'zoomSpeedFine', 'zoomSpeedVal', 3)
};

// Standard elements
const elAntialiasing = document.getElementById('antialiasing');
const elGrayscale = document.getElementById('grayscale');
const elCenterZoom = document.getElementById('centerZoom');
const elZoomDirection = document.getElementById('zoomDirection');

function encodeURL() {
  const urlParams = new URLSearchParams();
  const currentParams = {
    iter: Math.round(params.iter.getValue()),
    scale: params.scale.getValue(),
    dens: params.dens.getValue(),
    speed: params.speed.getValue(),
    cf: params.cf.getValue(),
    contract: params.contract.getValue(),
    sat: params.sat.getValue(),
    brightness: params.brightness.getValue(),
    ph: params.ph.getValue(),
    res: params.res.getValue(),
    zoom: zoom,
    panX: pan.x,
    panY: pan.y,
    zoomSpeed: params.zoomSpeed.getValue(),
    centerZoom: elCenterZoom.checked,
    zoomDirection: elZoomDirection.checked,
    antialiasing: elAntialiasing.checked,
    grayscale: elGrayscale.checked
  };
  
  // Only include non-default parameters
  Object.keys(currentParams).forEach(key => {
    const value = currentParams[key];
    const defaultValue = defaultParams[key];
    if (Math.abs(value - defaultValue) > 0.0001 || value !== defaultValue) {
      if (typeof value === 'boolean') {
        if (value !== defaultValue) urlParams.set(key, value ? '1' : '0');
      } else {
        urlParams.set(key, value.toFixed(6));
      }
    }
  });
  
  const baseUrl = window.location.origin + window.location.pathname;
  const fullUrl = urlParams.toString() ? `${baseUrl}?${urlParams.toString()}` : baseUrl;
  return fullUrl;
}

function decodeURL() {
  const urlParams = new URLSearchParams(window.location.search);
  
  if (urlParams.has('iter')) params.iter.setValue(parseInt(urlParams.get('iter')));
  if (urlParams.has('scale')) params.scale.setValue(parseFloat(urlParams.get('scale')));
  if (urlParams.has('dens')) params.dens.setValue(parseFloat(urlParams.get('dens')));
  if (urlParams.has('speed')) params.speed.setValue(parseFloat(urlParams.get('speed')));
  if (urlParams.has('cf')) params.cf.setValue(parseFloat(urlParams.get('cf')));
  if (urlParams.has('contract')) params.contract.setValue(parseFloat(urlParams.get('contract')));
  if (urlParams.has('sat')) params.sat.setValue(parseFloat(urlParams.get('sat')));
  if (urlParams.has('brightness')) params.brightness.setValue(parseFloat(urlParams.get('brightness')));
  if (urlParams.has('ph')) params.ph.setValue(parseFloat(urlParams.get('ph')));
  if (urlParams.has('res')) params.res.setValue(parseFloat(urlParams.get('res')));
  if (urlParams.has('zoomSpeed')) params.zoomSpeed.setValue(parseFloat(urlParams.get('zoomSpeed')));
  
  if (urlParams.has('zoom')) zoom = parseFloat(urlParams.get('zoom'));
  if (urlParams.has('panX')) pan.x = parseFloat(urlParams.get('panX'));
  if (urlParams.has('panY')) pan.y = parseFloat(urlParams.get('panY'));
  
  if (urlParams.has('centerZoom')) elCenterZoom.checked = urlParams.get('centerZoom') === '1';
  if (urlParams.has('zoomDirection')) elZoomDirection.checked = urlParams.get('zoomDirection') === '1';
  if (urlParams.has('antialiasing')) elAntialiasing.checked = urlParams.get('antialiasing') === '1';
  if (urlParams.has('grayscale')) elGrayscale.checked = urlParams.get('grayscale') === '1';
  
  updateNavigationDisplay();
  updateZoomSpeedDisplay();
  updateResolutionDisplay();
  updateRenderingMode();
}

function updateResolutionDisplay() {
  const scale = Math.max(0, Math.min(1, params.res.getValue()));
  const baseW = innerWidth;
  const baseH = innerHeight;
  const minSize = 8;
  
  const actualW = scale === 0 ? minSize : Math.max(minSize, Math.floor(baseW * scale));
  const actualH = scale === 0 ? minSize : Math.max(minSize, Math.floor(baseH * scale));
  
  if (scale === 0) {
    resolutionInfo.textContent = `${minSize}√ó${minSize} (minimum)`;
  } else if (scale >= 0.999) {
    resolutionInfo.textContent = `${actualW}√ó${actualH} (native)`;
  } else {
    const percent = Math.round(scale * 100);
    resolutionInfo.textContent = `${actualW}√ó${actualH} (${percent}%)`;
  }
  updateURL();
}

function updateRenderingMode() {
  const antialiasing = elAntialiasing.checked;
  
  if (antialiasing) {
    canvas.classList.remove('point-filtered');
    canvas.classList.add('smooth-filtered');
  } else {
    canvas.classList.remove('smooth-filtered');
    canvas.classList.add('point-filtered');
  }
}

function updateNavigationDisplay() {
  zoomInfo.textContent = zoom.toFixed(8);
  panXInfo.textContent = pan.x.toFixed(8);
  panYInfo.textContent = pan.y.toFixed(8);
  updateURL();
}

function updateZoomSpeedDisplay() {
  const speed = Math.max(0, Math.min(1, params.zoomSpeed.getValue()));
  
  if (speed === 0) {
    zoomSpeedInfo.textContent = "Stopped";
  } else {
    const direction = elZoomDirection.checked ? "out" : "in";
    const rate = (speed * 100).toFixed(1);
    zoomSpeedInfo.textContent = `Zooming ${direction} at ${rate}% speed`;
  }
  updateURL();
}

// Event listeners
document.getElementById('resolution').addEventListener('input', () => {
  updateResolutionDisplay();
  resize();
});

elAntialiasing.addEventListener('change', () => {
  updateRenderingMode();
  resize();
  updateURL();
});

elGrayscale.addEventListener('change', updateURL);
elCenterZoom.addEventListener('change', updateURL);
elZoomDirection.addEventListener('change', updateZoomSpeedDisplay);

document.getElementById('stopZoom').addEventListener('click', () => {
  params.zoomSpeed.setValue(0);
  updateZoomSpeedDisplay();
});

function resize() {
  const resolutionScale = Math.max(0, Math.min(1, params.res.getValue()));
  const antialiasing = elAntialiasing.checked;
  
  const baseW = innerWidth;
  const baseH = innerHeight;
  const minSize = 8;
  
  let targetW, targetH;
  if (resolutionScale === 0) {
    targetW = targetH = minSize;
  } else {
    targetW = Math.max(minSize, Math.floor(baseW * resolutionScale));
    targetH = Math.max(minSize, Math.floor(baseH * resolutionScale));
  }
  
  const aaMultiplier = antialiasing ? 2.0 : 1.0;
  const finalW = Math.floor(targetW * aaMultiplier);
  const finalH = Math.floor(targetH * aaMultiplier);
  
  canvas.width = finalW;
  canvas.height = finalH;
  canvas.style.width = baseW + 'px';
  canvas.style.height = baseH + 'px';  // FIXED: was baseW + 'px'
  
  gl.viewport(0, 0, finalW, finalH);
  updateResolutionDisplay();
  updateRenderingMode();
}

addEventListener('resize', resize);
resize();



// WebGL setup

const vs = `
attribute vec2 a_pos;
varying vec2 v_uv;
void main(){
  v_uv = a_pos * 0.5 + 0.5;
  gl_Position = vec4(a_pos, 0.0, 1.0);
}
`;

const fs = `

#ifdef GL_ES
precision highp float;
#endif

varying vec2 v_uv;

uniform vec2  u_resolution;
uniform int   u_iterations;
uniform float u_scale;
uniform float u_density;
uniform float u_speed;
uniform float u_colorFreq;
uniform float u_colorPhase;
uniform float u_colorContract;
uniform float u_colorSaturation;
uniform float u_colorBrightness;
uniform vec2  u_pan;
uniform float u_zoom;
uniform bool  u_grayscale;

// Tetrahedron vertices
const vec3 TETRA_0 = vec3( 1.0,  1.0,  1.0);
const vec3 TETRA_1 = vec3( 1.0, -1.0, -1.0);
const vec3 TETRA_2 = vec3(-1.0,  1.0, -1.0);
const vec3 TETRA_3 = vec3(-1.0, -1.0,  1.0);


vec3 hsv2rgb(vec3 c){
  vec4 K = vec4(1.0, 2.0/3.0, 1.0/3.0, 3.0);
  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
}

vec3 accel(vec3 from, vec3 to){
  vec3 r = to - from;
  float d2 = dot(r, r) + 1.0;
  float inv = inversesqrt(d2);
  return r * (inv * inv * inv);
}


float evalFractalTetra(vec2 uv){
  vec2 res = u_resolution;
  float aspect = res.x / max(res.y, 1.0);
  vec2 p = (uv * 2.0 - 1.0);
  p.x *= aspect;
  p = (p / u_zoom) + u_pan;
  
  float d = u_density;
  vec3 P = u_zoom > 1.0 && (u_pan.x * u_pan.x + u_pan.y * u_pan.y) < 3.14 ? vec3(p, 0) : vec3(sin(p.x), sin(p.y), 0);

  vec3 s = vec3(d * P.x, d * P.y, d * u_scale);

  vec3 pos0 = TETRA_0 * s;
  vec3 pos1 = TETRA_1 * s;
  vec3 pos2 = TETRA_2 * s;
  vec3 pos3 = TETRA_3 * s;
  vec3 pos4 = vec3(0.0);
  
  vec3 v0 = vec3(0.0);
  vec3 v1 = vec3(0.00);
  vec3 v2 = vec3(0.00);
  vec3 v3 = vec3(0.0);
  vec3 v4 = vec3(u_speed);

  int esc = u_iterations;
  for (int i = 0; i < 256; i++){
    if (i >= u_iterations) break;

    vec3 a0 = accel(pos0, pos1) + accel(pos0, pos2) + accel(pos0, pos3) + accel(pos0, pos4);
    vec3 a1 = accel(pos1, pos0) + accel(pos1, pos2) + accel(pos1, pos3) + accel(pos1, pos4);
    vec3 a2 = accel(pos2, pos0) + accel(pos2, pos1) + accel(pos2, pos3) + accel(pos2, pos4);
    vec3 a3 = accel(pos3, pos0) + accel(pos3, pos1) + accel(pos3, pos2) + accel(pos3, pos4);
    vec3 a4 = accel(pos4, pos0) + accel(pos4, pos1) + accel(pos4, pos2) + accel(pos4, pos3);

    v0 += a0; v1 += a1; v2 += a2; v3 += a3; v4 += a4;
    pos0 += v0; pos1 += v1; pos2 += v2; pos3 += v3; pos4 += v4;

    if (dot(v0, v0) > 1.0 || dot(v1, v1) > 1.0 || 
        dot(v2, v2) > 1.0 || dot(v3, v3) > 1.0 || dot(v4,v4) > 1.0){
      esc = i; 
      break;
    }
  }
  return float(esc) / float(u_iterations);
}


void main(){
  // Choose your fractal version:
  float value = evalFractalTetra(v_uv);        // Original tetrahedron (fastest)
  float hue = sin(value * u_colorFreq + u_colorPhase) * 0.5 + 0.5;

  vec3 color = hsv2rgb(vec3(hue, u_colorSaturation, u_colorBrightness));
  color = pow(color, vec3(u_colorContract));

  if (u_grayscale){
    float g = dot(color, vec3(0.2126, 0.7152, 0.0722));
    color = vec3(g, g, g);
  }

  gl_FragColor = vec4(color, 1.0);
}
`;

// Compile and link shaders
function compile(type, src){
  const s = gl.createShader(type);
  gl.shaderSource(s, src);
  gl.compileShader(s);
  if(!gl.getShaderParameter(s, gl.COMPILE_STATUS)){
    console.error(gl.getShaderInfoLog(s));
    throw new Error('Shader compile failed');
  }
  return s;
}

function link(vs, fs){
  const p = gl.createProgram();
  gl.attachShader(p, vs); gl.attachShader(p, fs);
  gl.linkProgram(p);
  if(!gl.getProgramParameter(p, gl.LINK_STATUS)){
    console.error(gl.getProgramInfoLog(p));
    throw new Error('Program link failed');
  }
  return p;
}

const prog = link(compile(gl.VERTEX_SHADER, vs), compile(gl.FRAGMENT_SHADER, fs));
gl.useProgram(prog);

// Set up geometry
const buf = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, buf);
gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
  -1,-1,  3,-1,  -1,3
]), gl.STATIC_DRAW);

const a_pos = gl.getAttribLocation(prog, 'a_pos');
gl.enableVertexAttribArray(a_pos);
gl.vertexAttribPointer(a_pos, 2, gl.FLOAT, false, 0, 0);

// Uniform locations
const U = {
  res: gl.getUniformLocation(prog, 'u_resolution'),
  iter: gl.getUniformLocation(prog, 'u_iterations'),
  scale: gl.getUniformLocation(prog, 'u_scale'),
  dens: gl.getUniformLocation(prog, 'u_density'),
  speed: gl.getUniformLocation(prog, 'u_speed'),
  cf: gl.getUniformLocation(prog, 'u_colorFreq'),
  ph: gl.getUniformLocation(prog, 'u_colorPhase'),
  contract: gl.getUniformLocation(prog, 'u_colorContract'),
  sat: gl.getUniformLocation(prog, 'u_colorSaturation'),
  brightness: gl.getUniformLocation(prog, 'u_colorBrightness'),
  pan: gl.getUniformLocation(prog, 'u_pan'),
  zoom: gl.getUniformLocation(prog, 'u_zoom'),
  gray: gl.getUniformLocation(prog, 'u_grayscale')
};

// Actions
document.getElementById('resetBtn').addEventListener('click', () => {
  pan.x = 0; pan.y = 0; zoom = 1.0;
  params.zoomSpeed.setValue(0);
  updateNavigationDisplay();
  updateZoomSpeedDisplay();
});

document.getElementById('shareBtn').addEventListener('click', async () => {
  const url = encodeURL();
  try {
    await navigator.clipboard.writeText(url);
    const btn = document.getElementById('shareBtn');
    const originalText = btn.textContent;
    btn.textContent = '‚úì Copied!';
    setTimeout(() => btn.textContent = originalText, 1500);
  } catch (e) {
    // Fallback for older browsers - select the text
    urlInput.select();
    urlInput.setSelectionRange(0, 99999);
  }
});

document.getElementById('downloadBtn').addEventListener('click', async () => {
  const originalRes = params.res.getValue();
  
  params.res.setValue(1.0);
  updateResolutionDisplay();
  resize();
  
  renderFrame();
  await new Promise(resolve => requestAnimationFrame(resolve));
  
  canvas.toBlob((blob) => {
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `fractube-${Date.now()}.png`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
    
    params.res.setValue(originalRes);
    updateResolutionDisplay();
    resize();
  }, 'image/png', 1.0);
});

// Mouse interaction
function screenToFractal(screenX, screenY) {
  const rect = canvas.getBoundingClientRect();
  const x = (screenX - rect.left) / rect.width;
  const y = (screenY - rect.top) / rect.height;
  
  const aspect = canvas.width / Math.max(canvas.height, 1);
  let fx = (x * 2.0 - 1.0) * aspect;
  let fy = -(y * 2.0 - 1.0);
  
  fx = (fx / zoom) + pan.x;
  fy = (fy / zoom) + pan.y;
  
  return {x: fx, y: fy};
}

function applyZoom(clientX, clientY, factor) {
  if (elCenterZoom.checked) {
    zoom *= factor;
  } else {
    const mouseBeforeZoom = screenToFractal(clientX, clientY);
    zoom *= factor;
    const mouseAfterZoom = screenToFractal(clientX, clientY);
    
    pan.x += mouseBeforeZoom.x - mouseAfterZoom.x;
    pan.y += mouseBeforeZoom.y - mouseAfterZoom.y;
  }
  updateNavigationDisplay();
}

canvas.addEventListener('mousedown', e => {
  dragging = true; 
  last.x = e.clientX; 
  last.y = e.clientY;
  e.preventDefault();
});

addEventListener('mouseup', () => dragging = false);

addEventListener('mousemove', e => {
  if (!dragging) return;
  
  const dx = e.clientX - last.x;
  const dy = e.clientY - last.y;
  last.x = e.clientX; 
  last.y = e.clientY;

  const sensitivity = 2.0 / Math.max(innerHeight, 1);
  
  pan.x -= dx * sensitivity / zoom;
  pan.y += dy * sensitivity / zoom;
  
  updateNavigationDisplay();
});

canvas.addEventListener('wheel', e => {
  e.preventDefault();
  const factor = Math.exp((e.deltaY < 0 ? 1 : -1) * 0.1);
  applyZoom(e.clientX, e.clientY, factor);
}, {passive: false});

// Touch support
let touchDist = 0;
let touchCenter = {x: 0, y: 0};

canvas.addEventListener('touchstart', e => {
  if (e.touches.length === 1) {
    dragging = true; 
    last.x = e.touches[0].clientX; 
    last.y = e.touches[0].clientY;
  } else if (e.touches.length === 2) {
    dragging = false;
    const dx = e.touches[0].clientX - e.touches[1].clientX;
    const dy = e.touches[0].clientY - e.touches[1].clientY;
    touchDist = Math.hypot(dx, dy);
    touchCenter.x = (e.touches[0].clientX + e.touches[1].clientX) / 2;
    touchCenter.y = (e.touches[0].clientY + e.touches[1].clientY) / 2;
  }
  e.preventDefault();
}, {passive: false});

canvas.addEventListener('touchmove', e => {
  if (e.touches.length === 1 && dragging) {
    const dx = e.touches[0].clientX - last.x;
    const dy = e.touches[0].clientY - last.y;
    last.x = e.touches[0].clientX; 
    last.y = e.touches[0].clientY;
    
    const sensitivity = 2.0 / Math.max(innerHeight, 1);
    
    pan.x -= dx * sensitivity / zoom;
    pan.y += dy * sensitivity / zoom;
    
    updateNavigationDisplay();
    
  } else if (e.touches.length === 2) {
    const dx = e.touches[0].clientX - e.touches[1].clientX;
    const dy = e.touches[0].clientY - e.touches[1].clientY;
    const d = Math.hypot(dx, dy);
    
    const newCenter = {
      x: (e.touches[0].clientX + e.touches[1].clientX) / 2,
      y: (e.touches[0].clientY + e.touches[1].clientY) / 2
    };
    
    if (touchDist > 0) {
      const factor = d / touchDist;
      applyZoom(touchCenter.x, touchCenter.y, factor);
    }
    
    touchDist = d;
    touchCenter = newCenter;
  }
  e.preventDefault();
}, {passive: false});

addEventListener('touchend', () => { 
  dragging = false; 
  touchDist = 0; 
}, {passive: false});

// Rendering
function updateAnimatedZoom() {
  const zoomSpeedValue = Math.max(0, Math.min(1, params.zoomSpeed.getValue()));
  
  if (zoomSpeedValue > 0) {
    const direction = elZoomDirection.checked ? -1 : 1;
    const factor = Math.exp(direction * zoomSpeedValue * 0.02);
    zoom *= factor;
    updateNavigationDisplay();
  }
}

function renderFrame() {
  gl.clearColor(0,0,0,1);
  gl.clear(gl.COLOR_BUFFER_BIT);

  gl.uniform2f(U.res, canvas.width, canvas.height);
  gl.uniform1i(U.iter, Math.round(params.iter.getValue()));
  gl.uniform1f(U.scale,params.scale.getValue());
  gl.uniform1f(U.dens, params.dens.getValue());
  gl.uniform1f(U.speed, params.speed.getValue());
  gl.uniform1f(U.cf, params.cf.getValue());
  gl.uniform1f(U.ph, params.ph.getValue());
  gl.uniform1f(U.contract, params.contract.getValue());
  gl.uniform1f(U.sat, params.sat.getValue());
  gl.uniform1f(U.brightness, params.brightness.getValue());
  gl.uniform2f(U.pan, pan.x, pan.y);
  gl.uniform1f(U.zoom, zoom);
  gl.uniform1i(U.gray, !!elGrayscale.checked);

  gl.drawArrays(gl.TRIANGLES, 0, 3);
}

function frame() {
  updateAnimatedZoom();
  renderFrame();
  requestAnimationFrame(frame);
}

// Initialize
decodeURL();
frame();
</script>
</body>
</html>
